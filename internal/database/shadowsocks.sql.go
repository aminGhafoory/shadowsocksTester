// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: shadowsocks.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createShadowsocks = `-- name: CreateShadowsocks :one
INSERT INTO ss(
    created_at ,
    updated_at ,
    ssLink,
    ip,
    sub_id,
    port ,
    secret,
    name  

)VALUES(
    $1,$2,$3,$4,$5,$6,$7,$8

)
RETURNING id, sub_id, created_at, updated_at, sslink, ip, port, secret, name, api_reported_ip
`

type CreateShadowsocksParams struct {
	CreatedAt time.Time
	UpdatedAt time.Time
	Sslink    string
	Ip        string
	SubID     int32
	Port      int32
	Secret    string
	Name      string
}

func (q *Queries) CreateShadowsocks(ctx context.Context, arg CreateShadowsocksParams) (Ss, error) {
	row := q.db.QueryRowContext(ctx, createShadowsocks,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Sslink,
		arg.Ip,
		arg.SubID,
		arg.Port,
		arg.Secret,
		arg.Name,
	)
	var i Ss
	err := row.Scan(
		&i.ID,
		&i.SubID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sslink,
		&i.Ip,
		&i.Port,
		&i.Secret,
		&i.Name,
		&i.ApiReportedIp,
	)
	return i, err
}

const getAllSSs = `-- name: GetAllSSs :many
SELECT id, sub_id, created_at, updated_at, sslink, ip, port, secret, name, api_reported_ip FROM ss
`

func (q *Queries) GetAllSSs(ctx context.Context) ([]Ss, error) {
	rows, err := q.db.QueryContext(ctx, getAllSSs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ss
	for rows.Next() {
		var i Ss
		if err := rows.Scan(
			&i.ID,
			&i.SubID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Sslink,
			&i.Ip,
			&i.Port,
			&i.Secret,
			&i.Name,
			&i.ApiReportedIp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestList = `-- name: GetBestList :many
SELECT 
    ss.id,
    ss.secret,
    ss.ip,
    ss.port,
    ss.name,
    ss.ssLink,
    avg(response_time) as avg_response_time,
	sum(case is_successful when true then 1 else 0 end) as successful_count,
	sum(case is_successful when false then 1 else 0 end) as failure_count
FROM
    ss JOIN reqs ON ss.id = reqs.ss_id

GROUP BY 
	ss.id
HAVING 
    avg(response_time)>0
ORDER BY 
	successful_count Desc,
    avg_response_time ASC
`

type GetBestListRow struct {
	ID              int64
	Secret          string
	Ip              string
	Port            int32
	Name            string
	Sslink          string
	AvgResponseTime float64
	SuccessfulCount int64
	FailureCount    int64
}

func (q *Queries) GetBestList(ctx context.Context) ([]GetBestListRow, error) {
	rows, err := q.db.QueryContext(ctx, getBestList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBestListRow
	for rows.Next() {
		var i GetBestListRow
		if err := rows.Scan(
			&i.ID,
			&i.Secret,
			&i.Ip,
			&i.Port,
			&i.Name,
			&i.Sslink,
			&i.AvgResponseTime,
			&i.SuccessfulCount,
			&i.FailureCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextSSToTest = `-- name: GetNextSSToTest :many
SELECT 
    id, sub_id, created_at, updated_at, sslink, ip, port, secret, name, api_reported_ip 
    FROM 
        ss 
ORDER BY 
    updated_at ASC 
LIMIT $1
`

func (q *Queries) GetNextSSToTest(ctx context.Context, limit int32) ([]Ss, error) {
	rows, err := q.db.QueryContext(ctx, getNextSSToTest, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ss
	for rows.Next() {
		var i Ss
		if err := rows.Scan(
			&i.ID,
			&i.SubID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Sslink,
			&i.Ip,
			&i.Port,
			&i.Secret,
			&i.Name,
			&i.ApiReportedIp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDestinationIP = `-- name: UpdateDestinationIP :one
UPDATE ss
SET 
    api_reported_ip = $1,
    updated_at = NOW()
WHERE 
    id = $2
RETURNING id, sub_id, created_at, updated_at, sslink, ip, port, secret, name, api_reported_ip
`

type UpdateDestinationIPParams struct {
	ApiReportedIp sql.NullString
	ID            int64
}

func (q *Queries) UpdateDestinationIP(ctx context.Context, arg UpdateDestinationIPParams) (Ss, error) {
	row := q.db.QueryRowContext(ctx, updateDestinationIP, arg.ApiReportedIp, arg.ID)
	var i Ss
	err := row.Scan(
		&i.ID,
		&i.SubID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sslink,
		&i.Ip,
		&i.Port,
		&i.Secret,
		&i.Name,
		&i.ApiReportedIp,
	)
	return i, err
}
